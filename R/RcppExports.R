# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' count function
#' counts the number of times a value appears in an IntegerVector
#' @param vec: a NumericVector
#' @param target: input integer value to find
#' @return scalar value of the number of times the target appears in vec
#' @examples count(c(1,2,3,4),3)
#' @export
count <- function(vec, target) {
    .Call('_popgen_tools_count', PACKAGE = 'popgen.tools', vec, target)
}

#' theta_h function
#' 
#' Computes theta_h for a genome matrix
#' 
#' @param G: Binary genome matrix with 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of theta_h for that sampled population
#' @examples theta_h(G)
#' @export
theta_h <- function(G) {
    .Call('_popgen_tools_theta_h', PACKAGE = 'popgen.tools', G)
}

#' fwh function
#' 
#' Computes Fay and Wu's H for a genome matrix. Strength of H indicates magnitude of selective sweep. H=0 indicates there is no evidence of deviation from neutrality.
#' 
#' @param t_w: theta_w for genome matrix G. Use theta_w(). Also called theta_pi in literature, 
#' @param t_h: theta_h for genome matrix G. Use theta_h().
#' @return scalar value of Fay and Wu's H for that sampled population.  
#' @examples fwh(theta_w(G),theta_h(G))
#' @export
fwh <- function(t_w, t_h) {
    .Call('_popgen_tools_fwh', PACKAGE = 'popgen.tools', t_w, t_h)
}

#' h_stats function
#' 
#' Computes the h1,h2,h12 statistics. For more information see https://doi.org/10.1371/journal.pgen.1005004.
#' 
#' @param G: A binary genome matrix consisting of 1's and 0's. Each column is a SNP. Each row is a sampled individual. 
#' @return A numeric vector of h stats. (h1,h2,h12)
#' @examples h_stats(G)
#' @export
h_stats <- function(G) {
    .Call('_popgen_tools_h_stats', PACKAGE = 'popgen.tools', G)
}

rcpp_hello_world <- function() {
    .Call('_popgen_tools_rcpp_hello_world', PACKAGE = 'popgen.tools')
}

#' sub_win function
#' 
#' Breaks down a matrix into a series of equal sized, non-overlapping windows.
#' 
#' @param G: A binary matrix of 0's and 1's. 
#' @param num_win: Number of subwindows to break G into. 
#' @return A NumericMatrix list of the windows
#' @examples sub_win(G,4)
#' @export
sub_win <- function(G, num_windows) {
    .Call('_popgen_tools_sub_win', PACKAGE = 'popgen.tools', G, num_windows)
}

a1f <- function(N) {
    .Call('_popgen_tools_a1f', PACKAGE = 'popgen.tools', N)
}

a2f <- function(N) {
    .Call('_popgen_tools_a2f', PACKAGE = 'popgen.tools', N)
}

b1f <- function(N) {
    .Call('_popgen_tools_b1f', PACKAGE = 'popgen.tools', N)
}

b2f <- function(N) {
    .Call('_popgen_tools_b2f', PACKAGE = 'popgen.tools', N)
}

c1f <- function(b1, a1) {
    .Call('_popgen_tools_c1f', PACKAGE = 'popgen.tools', b1, a1)
}

c2f <- function(a1, a2, b2, N) {
    .Call('_popgen_tools_c2f', PACKAGE = 'popgen.tools', a1, a2, b2, N)
}

e1f <- function(c1, a1) {
    .Call('_popgen_tools_e1f', PACKAGE = 'popgen.tools', c1, a1)
}

e2f <- function(a1, a2, c2) {
    .Call('_popgen_tools_e2f', PACKAGE = 'popgen.tools', a1, a2, c2)
}

#' theta_t function
#' 
#' Computes theta_t, the number of pairwise differences normalised by the number of pairs. 
#' 
#' @param G: G: Binary genome matrix of 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of theta_t
#' @examples theta_t(G)
#' @export
theta_t <- function(G) {
    .Call('_popgen_tools_theta_t', PACKAGE = 'popgen.tools', G)
}

#'theta_w function
#'
#' Computes the average number of pairwise differences. 
#' 
#' @param G: Binary genome matrix of 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value opf theta_w
#' @examples theta_w(G)
#' @export
theta_w <- function(G) {
    .Call('_popgen_tools_theta_w', PACKAGE = 'popgen.tools', G)
}

#' var_taj function
#' 
#' Computes the variance of the nominator term in tajima's D. 
#' 
#' @param G: Binary genome matrix of 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of the variance term in tajima's D.
#' @examples var_taj(G)
#' @export
var_taj <- function(G) {
    .Call('_popgen_tools_var_taj', PACKAGE = 'popgen.tools', G)
}

#' taj_D function
#' 
#' Computes Tajima's D for a genome matrix. 
#' 
#' @param t_t: theta_t for geneom matrix G. Use theta_t()
#' @param t_w: theta_w for genome matrix G. Use theta_w()
#' @param var_taj: Variance of tajima's D. Use var_taj()
#' @return a scalar value of tajima's D for the sampled population. 
#' @examples taj_D(theta_t(G),theta_w(G),var_taj(G))
#' @export
taj_D <- function(t_t, t_w, var_taj) {
    .Call('_popgen_tools_taj_D', PACKAGE = 'popgen.tools', t_t, t_w, var_taj)
}

#' fill_row function
#' takes a NumericVector and adds it as a new row on the bottom of a matrix
#' @param A: A NumericMatrix.
#' @param x: A NumericVector. 
fill_row <- function(A, x) {
    .Call('_popgen_tools_fill_row', PACKAGE = 'popgen.tools', A, x)
}

#' present_row function
#' 
#' checks if a vector is present as a row in the input matrix
#' 
#' @param A: NumericMatrix
#' @param x: NumericVector
#' @return integer reocrding how many times the vector is present as a row in the matrix
#' @export
present_row <- function(A, x) {
    .Call('_popgen_tools_present_row', PACKAGE = 'popgen.tools', A, x)
}

#' unique_rows function
#' 
#' Takes a NumericMatrix and returns the frequency of all the unique rows as a NumericVectior.
#' 
#' @param A: A general matrix of real values.
#' @return A NumericVector. i'th element is the frequency of the i'th unique row.
#' @examples unique_rows(A)
#' @export
unique_rows <- function(A) {
    .Call('_popgen_tools_unique_rows', PACKAGE = 'popgen.tools', A)
}

three_top <- function(x) {
    .Call('_popgen_tools_three_top', PACKAGE = 'popgen.tools', x)
}

#' vec_equal function for cpp
#' @param x,y: two numeric vectors of the same dimensions
#' @return boolean, true if the two vectors are the same. False otherwise. 
#' @examples vec_equal(x,y)
#' @export
vec_equal <- function(x, y) {
    .Call('_popgen_tools_vec_equal', PACKAGE = 'popgen.tools', x, y)
}

#' w_max function
#' 
#' Computes w_max for a binary, genome matrix. Each column is a SNP, each row is a sample. 
#' 
#' @param G: Binary genome matrix consisting of 1's and 0's.
#' @return scalar value of w_max for the genome matrix
#' @examples w_max(G)
#' @export
w_max <- function(x) {
    .Call('_popgen_tools_w_max', PACKAGE = 'popgen.tools', x)
}

