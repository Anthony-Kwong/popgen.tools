# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' theta_h function
#' Computes theta_h for a genome matrix
#' @param G: Binary genome matrix with 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of theta_h for that sampled population
#' @examples
#' @export
theta_h <- function(G) {
    .Call('_popgen_tools_theta_h', PACKAGE = 'popgen.tools', G)
}

#' fwh function
#' Computes Fay and Wu's H for a genome matrix. 
#' @param G: Binary genome matrix with 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of Fay and Wu's H for that sampled population.  
#' @examples
#' @export
fwh <- function(x) {
    .Call('_popgen_tools_fwh', PACKAGE = 'popgen.tools', x)
}

#' h_stats function
#' 
#' Computes the h1,h2,h12 statistics. For more information see https://doi.org/10.1371/journal.pgen.1005004.
#' 
#' @param G: A binary genome matrix consisting of 1's and 0's. Each column is a SNP. Each row is a sampled individual. 
#' @return A numeric vector of h stats. (h1,h2,h12)
#' @examples h_stats(G)
#' @export
h_stats <- function(G) {
    .Call('_popgen_tools_h_stats', PACKAGE = 'popgen.tools', G)
}

rcpp_hello_world <- function() {
    .Call('_popgen_tools_rcpp_hello_world', PACKAGE = 'popgen.tools')
}

#' sub_win function
#' Breaks down a matrix into a series of equal sized, non-overlapping windows
#' @param G: A binary matrix of 0's and 1's. 
#' @param num_win: Number of subwindows to break G into. 
#' @returns A NumericMatrix list of the windows
sub_win <- function(G, num_windows) {
    .Call('_popgen_tools_sub_win', PACKAGE = 'popgen.tools', G, num_windows)
}

a1f <- function(N) {
    .Call('_popgen_tools_a1f', PACKAGE = 'popgen.tools', N)
}

a2f <- function(N) {
    .Call('_popgen_tools_a2f', PACKAGE = 'popgen.tools', N)
}

b1f <- function(N) {
    .Call('_popgen_tools_b1f', PACKAGE = 'popgen.tools', N)
}

b2f <- function(N) {
    .Call('_popgen_tools_b2f', PACKAGE = 'popgen.tools', N)
}

c1f <- function(b1, a1) {
    .Call('_popgen_tools_c1f', PACKAGE = 'popgen.tools', b1, a1)
}

c2f <- function(a1, a2, b2, N) {
    .Call('_popgen_tools_c2f', PACKAGE = 'popgen.tools', a1, a2, b2, N)
}

e1f <- function(c1, a1) {
    .Call('_popgen_tools_e1f', PACKAGE = 'popgen.tools', c1, a1)
}

e2f <- function(a1, a2, c2) {
    .Call('_popgen_tools_e2f', PACKAGE = 'popgen.tools', a1, a2, c2)
}

#' theta_t function
#' Computes theta_t, the number of pairwise differences normalised by the number of pairs. 
#' @param G: G: Binary genome matrix of 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of theta_t
#' @examples theta_t(G)
#' @export
theta_t <- function(G) {
    .Call('_popgen_tools_theta_t', PACKAGE = 'popgen.tools', G)
}

#'theta_w function
#' Computes the average number of pairwise differences. 
#' @param G: Binary genome matrix of 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value opf theta_w
#' @examples theta_w(G)
#' @export
theta_w <- function(G) {
    .Call('_popgen_tools_theta_w', PACKAGE = 'popgen.tools', G)
}

#' taj_D function
#' Computes Tajima's D for a genome matrix. 
#' @param G: A binary matrix of 0's and 1's. Each column is a SNP and each row is a sampled individual.
#' @return a scalar value of tajima's D for the sampled population. 
#' @examples taj_D(G)
#' @export
taj_D <- function(G) {
    .Call('_popgen_tools_taj_D', PACKAGE = 'popgen.tools', G)
}

#' fill_row function
#' takes a NumericVector and adds it as a new row on the bottom of a matrix
#' @param A: A NumericMatrix.
#' @param x: A NumericVector. 
fill_row <- function(A, x) {
    .Call('_popgen_tools_fill_row', PACKAGE = 'popgen.tools', A, x)
}

#' present_row function
#' 
#' checks if a vector is present as a row in the input matrix
#' 
#' @param A: NumericMatrix
#' @param x: NumericVector
#' @return integer reocrding how many times the vector is present as a row in the matrix
#' @export
present_row <- function(A, x) {
    .Call('_popgen_tools_present_row', PACKAGE = 'popgen.tools', A, x)
}

#' unique_rows function
#' 
#' Takes a NumericMatrix and returns the frequency of all the unique rows as a NumericVectior.
#' 
#' @param A: A general matrix of real values.
#' @return A NumericVector. i'th element is the frequency of the i'th unique row.
#' @examples unique_rows(A)
#' @export
unique_rows <- function(A) {
    .Call('_popgen_tools_unique_rows', PACKAGE = 'popgen.tools', A)
}

three_top <- function(x) {
    .Call('_popgen_tools_three_top', PACKAGE = 'popgen.tools', x)
}

#' vec_equal function for cpp
#' @param x,y: two numeric vectors of the same dimensions
#' @return boolean, true if the two vectors are the same. False otherwise. 
#' @examples vec_equal(x,y)
#' @export
vec_equal <- function(x, y) {
    .Call('_popgen_tools_vec_equal', PACKAGE = 'popgen.tools', x, y)
}

