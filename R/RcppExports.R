# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' any_sug function
#' 
#' A wrapper for the sugar function any. It takes a LogicalVector and returns T if any of the elements are T.
#' Source: https://gallery.rcpp.org/articles/sugar-any/
#' 
#' @param x: LogicalVector.
#' @return A boolean.
#' @examples  x <- c(3, 9, 0, 2, 7, -1, 6)
#' any_sug(x>9)
#' @export
any_sug <- function(x) {
    .Call('_popgen_tools_any_sug', PACKAGE = 'popgen.tools', x)
}

#' find_index function
#' 
#' Searches a NumericVector for the element that is closest to a target value. 
#' Returns the corresponding index. 
#' 
#' @param x: A NumericVector with the elements are arranged in ascending order. 
#' @param target: a double
#' @return An integer for the index of the closest element in NumericVector x
#' @examples x<-runif(0,1,n=5) %>% sort(), target=0.2, find_index(x,target)
#' @export
find_index <- function(x, target) {
    .Call('_popgen_tools_find_index', PACKAGE = 'popgen.tools', x, target)
}

#' first_over function
#' Takes in a sorted NumericVector and a target double. Find the first element
#' in the vector which is larger than the target. Returns the index. Recall R 
#' starts indices at 1 and this is what the function uses. 
#' 
#' @param x: A sorted NumericVector
#' @param target: A double.
#' @return An integer for the index of the first element in x that is larger than the target.
#' @examples x<-runif(0,1,n=5) %>% sort() 
#' target=0.2 
#' find_index(x,target)
#' @export
first_over <- function(x, target) {
    .Call('_popgen_tools_first_over', PACKAGE = 'popgen.tools', x, target)
}

#' count function
#' 
#' counts the number of times a value appears in an IntegerVector
#' @param vec: a NumericVector
#' @param target: input integer value to find
#' @return scalar value of the number of times the target appears in vec
#' @examples count(c(1,2,3,4),3)
#' @export
count <- function(vec, target) {
    .Call('_popgen_tools_count', PACKAGE = 'popgen.tools', vec, target)
}

#' theta_h function
#' 
#' Computes theta_h for a genome matrix
#' 
#' @param G: Binary genome matrix with 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of theta_h for that sampled population. 
#' @examples theta_h(G)
#' @export
theta_h <- function(G) {
    .Call('_popgen_tools_theta_h', PACKAGE = 'popgen.tools', G)
}

#' fwh function
#' 
#' Computes Fay and Wu's H for a genome matrix. Strength of H indicates magnitude of selective sweep. H=0 indicates there is no evidence of deviation from neutrality. See doi: 10.1534/genetics.106.061432.
#' 
#' @param t_t: theta_t for genome matrix G. Use theta_t(). Also called theta_pi in literature, 
#' @param t_h: theta_h for genome matrix G. Use theta_h().
#' @return scalar value of Fay and Wu's H for that sampled population.  
#' @examples fwh(theta_t(G),theta_h(G))
#' @export
fwh <- function(t_t, t_h) {
    .Call('_popgen_tools_fwh', PACKAGE = 'popgen.tools', t_t, t_h)
}

#' h_stats function
#' 
#' Computes the h1,h2,h12,h123 statistics. For more information on how these are computed see https://doi.org/10.1371/journal.pgen.1005004.
#' 
#' @param G: A NumericMatrix designating a binary genome matrix consisting of 1's and 0's. Each column is a SNP. Each row is a sampled individual. 
#' @return A numeric vector of h stats. (h1,h2,h12,h123)
#' @examples h_stats(G)
#' @export
h_stats <- function(G) {
    .Call('_popgen_tools_h_stats', PACKAGE = 'popgen.tools', G)
}

#' have_na function
#' 
#' Checks if a NumericMatrix has any NA values. Returns T if it does, F otherwise.
#' 
#' @param M: A NumericMatrix
#' @return A boolean indicating whether the input matrix has any NAs. 
#' @examples A = matrix(1:4, nrow = 2)
#' have_na(A)
#' @export 
have_na <- function(M) {
    .Call('_popgen_tools_have_na', PACKAGE = 'popgen.tools', M)
}

#' het_finder function
#' 
#' Searches through the columns of a NumericMatrix and finds all the columns that 
#' contain different elements. Returns the indices of these columns. Note that 
#' this function uses 1 indexing to suit R. 
#' 
#' @param G: A NumericMatrix
#' @return A NumericVector containing the indices of the columns with different elements.
#' @examples  G <-matrix(sample(0:1, size = 16, replace = TRUE), nc = 4), het_finder(G)
#' @export
het_finder <- function(G) {
    .Call('_popgen_tools_het_finder', PACKAGE = 'popgen.tools', G)
}

#' is_sorted function
#' 
#' Checks if a NumericVector is sorted numerically. 
#' 
#' @param x: NumericVector
#' @param ascend: A boolean. If TRUE, checks if the elements of x are in ascending order.
#' If FALSE, checks if they are in descending order. 
#' @return A boolean indicating whether the vector is sorted.
#' @examples x = c(1,3,5,7)
#' is_sorted(x, ascend = T)
#' @export 
is_sorted <- function(x, ascend) {
    .Call('_popgen_tools_is_sorted', PACKAGE = 'popgen.tools', x, ascend)
}

#' matrix_subset function
#' 
#' Subsets selected columns from a NumericMatrix. 
#' 
#' @param G: A NumericMatrix
#' @param y: An IntegerVector of indices. Uses 1 indexing to suit R.
#' @return A NumericMatrix with subset columns of G using the indices in y.
#' @export
matrix_subset <- function(G, y) {
    .Call('_popgen_tools_matrix_subset', PACKAGE = 'popgen.tools', G, y)
}

#' random_impute function
#' 
#' Imputes NAs in a genome matrix. For each NA, we randomly sample from the non-NA
#' elements of that column. Each element is equally likely to be selected. NA becomes
#' the randomly selected element. 
#' 
#' @param G: A NumericMatrix with NAs. 
#' @param seed: A numeric random seed.
#' @return A NumericMatrix with imputed values in place of the NAs. 
#' @examples G <-matrix(sample(0:1, size = 16, replace = TRUE), nc = 4)
#' G[1,1] = NA
#' random_impute(G)
#' @export
random_impute <- function(G) {
    .Call('_popgen_tools_random_impute', PACKAGE = 'popgen.tools', G)
}

rcpp_hello_world <- function() {
    .Call('_popgen_tools_rcpp_hello_world', PACKAGE = 'popgen.tools')
}

#' sub_win function
#' 
#' Breaks down a matrix into a series of equal sized, non-overlapping windows. When
#' the number of columns is not divisible by the number of subwindows, the remaining
#' columns go onto the last window. 
#' 
#' @param G: A binary matrix of 0's and 1's. 
#' @param num_win: Number of subwindows to break G into. 
#' @return A List of 2 elements. 1. A list of NumericMatrix for the windows. 
#' 2. A NumericVector of column indices, indicating the boundary points for each window. 
#' We use the R setup where indices start at 1.
#' @examples sub_win(G,4)
#' @export
sub_win <- function(G, num_windows) {
    .Call('_popgen_tools_sub_win', PACKAGE = 'popgen.tools', G, num_windows)
}

a1f <- function(N) {
    .Call('_popgen_tools_a1f', PACKAGE = 'popgen.tools', N)
}

a2f <- function(N) {
    .Call('_popgen_tools_a2f', PACKAGE = 'popgen.tools', N)
}

b1f <- function(N) {
    .Call('_popgen_tools_b1f', PACKAGE = 'popgen.tools', N)
}

b2f <- function(N) {
    .Call('_popgen_tools_b2f', PACKAGE = 'popgen.tools', N)
}

c1f <- function(b1, a1) {
    .Call('_popgen_tools_c1f', PACKAGE = 'popgen.tools', b1, a1)
}

c2f <- function(a1, a2, b2, N) {
    .Call('_popgen_tools_c2f', PACKAGE = 'popgen.tools', a1, a2, b2, N)
}

e1f <- function(c1, a1) {
    .Call('_popgen_tools_e1f', PACKAGE = 'popgen.tools', c1, a1)
}

e2f <- function(a1, a2, c2) {
    .Call('_popgen_tools_e2f', PACKAGE = 'popgen.tools', a1, a2, c2)
}

#' theta_t function
#' 
#' Computes theta_t, the number of pairwise differences normalised by the number of pairs. 
#' 
#' @param G: G: Binary genome matrix of 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of theta_t
#' @examples theta_t(G)
#' @export
theta_t <- function(G) {
    .Call('_popgen_tools_theta_t', PACKAGE = 'popgen.tools', G)
}

#'theta_w function
#'
#' Computes the average number of pairwise differences, assuming neutrality.
#' 
#' @param G: Binary genome matrix of 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of theta_w
#' @examples theta_w(G)
#' @export
theta_w <- function(G) {
    .Call('_popgen_tools_theta_w', PACKAGE = 'popgen.tools', G)
}

#' var_taj function
#' 
#' Computes the variance of the nominator term in tajima's D. 
#' 
#' @param G: Binary genome matrix of 0's and 1's. Each column is a SNP, each row is an individual.
#' @return scalar value of the variance term in tajima's D.
#' @examples var_taj(G)
#' @export
var_taj <- function(G) {
    .Call('_popgen_tools_var_taj', PACKAGE = 'popgen.tools', G)
}

#' taj_D function
#' 
#' Computes Tajima's D for a genome matrix. 
#' 
#' @param t_t: theta_t for geneom matrix G. Use theta_t()
#' @param t_w: theta_w for genome matrix G. Use theta_w()
#' @param var_taj: Variance of tajima's D. Use var_taj()
#' @return a scalar value of tajima's D for the sampled population. 
#' @examples taj_D(theta_t(G),theta_w(G),var_taj(G))
#' @export
taj_D <- function(t_t, t_w, var_taj) {
    .Call('_popgen_tools_taj_D', PACKAGE = 'popgen.tools', t_t, t_w, var_taj)
}

#' fill_row function
#' takes a NumericVector and adds it as a new row on the bottom of a matrix
#' @param A: A NumericMatrix
#' @param x: A NumericVector
#' @return a new matrix where vector x is bound as the bottom row of A
#' @examples fill_row(A,x)
#' @export
fill_row <- function(A, x) {
    .Call('_popgen_tools_fill_row', PACKAGE = 'popgen.tools', A, x)
}

#' row_count function
#' 
#' Counts how many times a vector is present as a row in a NumericMatrix.
#' 
#' @param A: NumericMatrix
#' @param x: NumericVector
#' @return integer recording how many times the vector is present as a row in the matrix
#' @export
row_count <- function(A, x) {
    .Call('_popgen_tools_row_count', PACKAGE = 'popgen.tools', A, x)
}

#' unique_rows function
#' 
#' Takes a NumericMatrix and returns all the unique rows as a NumericVector. The rows appear in the order they were in A. 
#' 
#' @param A: A general matrix of real values.
#' @return A NumericMatrix containing all the unique rows of A. 
#' @examples unique_rows(A)
#' @export
unique_rows <- function(A) {
    .Call('_popgen_tools_unique_rows', PACKAGE = 'popgen.tools', A)
}

#' row_freq function
#' 
#' Takes a NumericMatrix and returns the frequency of each unique row
#' 
#' @param NumericMatrix A
#' @return A NumericVector containing the frequency of each unique row in A. The order of this vector is the order by which the unique rows appear in A. 
#' @examples row_freq(A)
#' @export
row_freq <- function(A) {
    .Call('_popgen_tools_row_freq', PACKAGE = 'popgen.tools', A)
}

#' vec_sort function
#' 
#' Sorts the elements of a NumericVector in descending order
#' 
#' @param x: NumericVector
#' @return NumericVector with elements of x sorted in descending order
#' @examples x<-c(1,8,2,2,3)
#' vec_sort(x)
#' @export
vec_sort <- function(x) {
    .Call('_popgen_tools_vec_sort', PACKAGE = 'popgen.tools', x)
}

#' vec_equal function for cpp
#' @param x,y: two numeric vectors of the same dimensions
#' @return boolean, true if the two vectors are the same. False otherwise. 
#' @examples vec_equal(x,y)
#' @export
vec_equal <- function(x, y) {
    .Call('_popgen_tools_vec_equal', PACKAGE = 'popgen.tools', x, y)
}

#' vec_split function
#' 
#' Breaks a vector x into n equal sized blocks. If the dimension of x is not divisible by n, we put the remaining elements into the last block. 
#' 
#' @param x: vector to split
#' @param n: number of blocks to split a vector into. 
#' @return a list of vectors
#' @examples vec_split(seq(10),3)
#' @export
vec_split <- function(x, n) {
    .Call('_popgen_tools_vec_split', PACKAGE = 'popgen.tools', x, n)
}

#' vector_trim function
#' 
#' Trims outer elements of a vector based on some provided central index. 
#' 
#' @param x: NumericVector to trim
#' @param cen: Integer index for central element
#' @param k: Number of elements to retain from both sides of the center.
#' @return A NumericVector with outer elements removed. Up to k elements can be 
#' retained from both sides of the center. 
#' @examples x<-seq(1,5,by=1)
#' vector_trim(x,cen=3,k=1)
#' @export
vector_trim <- function(x, cen, k) {
    .Call('_popgen_tools_vector_trim', PACKAGE = 'popgen.tools', x, cen, k)
}

#' window_trim function
#' 
#' Trims the outer columns of a matrix. 
#' 
#' @param G: NumericMatrix
#' @param cen: An integer designating a column index. This will be the center column of the ouput matrix.
#' @param k: An integer for the number of columns to include on either side of the output matrix. 
#' @return A NumericMatrix with the outer columns of G removed. Up to k columns to either side of the center column from the original matrix is kept.
#' @examples window_trim(G,1,5)
#' @export
window_trim <- function(G, cen, k) {
    .Call('_popgen_tools_window_trim', PACKAGE = 'popgen.tools', G, cen, k)
}

#' winsplit_base function
#' 
#' Split a genome matrix into equally sized windows as determined by
#' the number of bases. The windows can differ in the number of columns
#' because SNPs are not always uniform across a given region. 
#' 
#' @param G: A NumericMatrix designating a binary genome matrix consisting of 1's and 0's. Each column is a SNP. Each row is a sampled individual. 
#' @param pos: A NumericVector consisting of values between 0,1. The ith element is the position of the ith SNP in G.
#' @param n: integer for the number of desired windows in the output list. 
#' @return A list of 2 elements. 1. A NumericMatrix list of the windows. 2. A double showing the length of each window.
#' @examples seq <-matrix(sample(0:1, size = 25, replace = TRUE), nc = 5)
#' pos<-runif(0,1,n=5) %>% sort()
#' winsplit_length(seq,pos,5)
#' @export
winsplit_base <- function(G, pos, n) {
    .Call('_popgen_tools_winsplit_base', PACKAGE = 'popgen.tools', G, pos, n)
}

